// THIS IS AN AUTOGENERATED TESTS, DO NOT MODIFY!
//
// The cargo dbcheck will generate the test files for each stage of the course.
// Be careful; these files are not intended to be edited by students. You're
// free to add more tests in separate files, but don't delete or edit tests
// generated by the testing tool

/* --------------- TESTS CREATED FROM TOKENIZER SPECIFICATION ---------------
 *             (see https://www.sqlite.org/draft/tokenreq.html)
 */
#![allow(non_snake_case)]

use super::{run_rainy_day_test, run_sunny_day_test};
use db_academy_sql_parser::{Keyword::*, TokenType, TokenizerError};

/// H41010: SQLite shall divide input SQL text into tokens working from left
/// to right
#[test]
fn test_H41010() {
    let sql = "SELECT * FROM public.users WHERE id = 42;";
    let expected_tokens = vec![
        TokenType::Keyword(Select),
        TokenType::Star,
        TokenType::Keyword(From),
        TokenType::Id("public"),
        TokenType::Dot,
        TokenType::Id("users"),
        TokenType::Keyword(Where),
        TokenType::Id("id"),
        TokenType::Equals,
        TokenType::Integer("42"),
        TokenType::Semi,
    ];
    run_sunny_day_test(sql, expected_tokens);
}

/// H41020: At each step in the SQL tokenization process, SQLite shall
/// extract the longest possible token from the remaining input text.
#[test]
fn test_H41020() {
    let sql = "SELECT a!=b, c||d FROM table1;";
    let expected_tokens = vec![
        TokenType::Keyword(Select),
        TokenType::Id("a"),
        TokenType::NotEquals, // '!='
        TokenType::Id("b"),
        TokenType::Comma,
        TokenType::Id("c"),
        TokenType::Concat, // '||'
        TokenType::Id("d"),
        TokenType::Keyword(From),
        TokenType::Id("table1"),
        TokenType::Semi,
    ];
    run_sunny_day_test(sql, expected_tokens);
}

/// H41030: The tokenizer shall pass each non-WHITESPACE token seen on to the
/// parser in the order in which the tokens are seen.
#[test]
fn test_H41030() {
    let sql = "  SELECT   id ,   name  FROM   users  WHERE   age  >= 18 ;";
    let expected_tokens = vec![
        TokenType::Keyword(Select),
        TokenType::Id("id"),
        TokenType::Comma,
        TokenType::Id("name"),
        TokenType::Keyword(From),
        TokenType::Id("users"),
        TokenType::Keyword(Where),
        TokenType::Id("age"),
        TokenType::GreaterEquals, // '>='
        TokenType::Integer("18"),
        TokenType::Semi,
    ];
    run_sunny_day_test(sql, expected_tokens);
}

/// H41040: When the tokenizer reaches the end of input where the last token
/// sent to the parser was not a SEMI token, it shall send a SEMI token to the parser.
#[test]
fn test_H41040() {
    let test_cases = vec![
        (
            "SELECT * FROM users", // No semicolon at the end
            vec![
                TokenType::Keyword(Select),
                TokenType::Star,
                TokenType::Keyword(From),
                TokenType::Id("users"),
                TokenType::Semi, // Implicit semicolon added
            ],
        ),
        (
            "INSERT INTO users (id) VALUES (1)", // No semicolon
            vec![
                TokenType::Keyword(Insert),
                TokenType::Keyword(Into),
                TokenType::Id("users"),
                TokenType::LeftParen,
                TokenType::Id("id"),
                TokenType::RightParen,
                TokenType::Keyword(Values),
                TokenType::LeftParen,
                TokenType::Integer("1"),
                TokenType::RightParen,
                TokenType::Semi, // Implicit semicolon added
            ],
        ),
        (
            "UPDATE users SET name = 'Alice' WHERE id = 1", // No semicolon
            vec![
                TokenType::Keyword(Update),
                TokenType::Id("users"),
                TokenType::Keyword(Set),
                TokenType::Id("name"),
                TokenType::Equals,
                TokenType::String("'Alice'"),
                TokenType::Keyword(Where),
                TokenType::Id("id"),
                TokenType::Equals,
                TokenType::Integer("1"),
                TokenType::Semi, // Implicit semicolon added
            ],
        ),
        (
            "DELETE FROM users WHERE id = 1", // No semicolon
            vec![
                TokenType::Keyword(Delete),
                TokenType::Keyword(From),
                TokenType::Id("users"),
                TokenType::Keyword(Where),
                TokenType::Id("id"),
                TokenType::Equals,
                TokenType::Integer("1"),
                TokenType::Semi, // Implicit semicolon added
            ],
        ),
        (
            "CREATE TABLE test (id INTEGER)", // No semicolon
            vec![
                TokenType::Keyword(Create),
                TokenType::Keyword(Table),
                TokenType::Id("test"),
                TokenType::LeftParen,
                TokenType::Id("id"),
                TokenType::Id("INTEGER"),
                TokenType::RightParen,
                TokenType::Semi, // Implicit semicolon added
            ],
        ),
        (
            "SELECT * FROM users;", // Semicolon present
            vec![
                TokenType::Keyword(Select),
                TokenType::Star,
                TokenType::Keyword(From),
                TokenType::Id("users"),
                TokenType::Semi, // Explicit semicolon
            ],
        ),
        (
            "SELECT * FROM users -- comment at the end", // Ends with a comment
            vec![
                TokenType::Keyword(Select),
                TokenType::Star,
                TokenType::Keyword(From),
                TokenType::Id("users"),
                TokenType::SingleLineComment(" comment at the end"),
                TokenType::Semi, // Implicit semicolon added
            ],
        ),
        (
            "SELECT * FROM users /* block comment */", // Ends with block comment
            vec![
                TokenType::Keyword(Select),
                TokenType::Star,
                TokenType::Keyword(From),
                TokenType::Id("users"),
                TokenType::MultiLineComment(" block comment "),
                TokenType::Semi, // Implicit semicolon added
            ],
        ),
    ];

    for (sql, expected_tokens) in test_cases {
        run_sunny_day_test(sql, expected_tokens);
    }
}

/// H41050: When the tokenizer encounters text that is not a valid token, it shall cause an error to be returned to the application.
#[test]
fn test_H41050() {
    run_rainy_day_test(
        "SELECT @ FROM users;",
        vec![TokenType::Keyword(Select)],
        TokenizerError::BadVariableName,
    );
}
