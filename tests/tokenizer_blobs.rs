// THIS IS AN AUTOGENERATED TESTS, DO NOT MODIFY!
//
// The cargo dbcheck will generate the test files for each stage of the course.
// Be careful; these files are not intended to be edited by students. You're
// free to add more tests in separate files, but don't delete or edit tests
// generated by the testing tool

/* --------------- TESTS DERIVED FROM TOKENIZER SPECIFICATION ---------------
 *             (see https://www.sqlite.org/draft/tokenreq.html)
 */
#![allow(non_snake_case)]

mod common;
use common::{run_rainy_day_test, run_sunny_day_test};
use sql_parser::{TokenType, TokenizerError};

/// H41210: SQLite shall recognize as a BLOB token an upper or lower-case "X"
/// (u0058 or u0078) followed by a single-quote (u0027) followed by a number of
/// HEXADECIMAL character that is a multiple of two and terminated by a
/// single-quote (u0027).
#[test]
fn test_H41210() {
    let valid_test_cases = vec![
        (
            "x'1A2B3C';",
            vec![TokenType::Blob("x'1A2B3C'"), TokenType::Semi],
        ),
        (
            "X'abc123';",
            vec![TokenType::Blob("X'abc123'"), TokenType::Semi],
        ),
        (
            "x'00FF';",
            vec![TokenType::Blob("x'00FF'"), TokenType::Semi],
        ),
        (
            "x'';", // Empty blob
            vec![TokenType::Blob("x''"), TokenType::Semi],
        ),
        (
            "x'0123456789ABCDEF';",
            vec![TokenType::Blob("x'0123456789ABCDEF'"), TokenType::Semi],
        ),
    ];

    for (sql, expected_tokens) in valid_test_cases {
        run_sunny_day_test(sql, expected_tokens);
    }
}

#[test]
fn test_H41210_rainy_day_cases() {
    let invalid_test_cases = vec![
        // Invalid hex character 'G'
        ("x'1G'", TokenizerError::MalformedBlobLiteral("x'1G'", 3)),
        // Odd number of hex digits
        ("x'123'", TokenizerError::MalformedBlobLiteral("x'123'", 6)),
        // Odd number of hex digits
        (
            "x'1A2B3'",
            TokenizerError::MalformedBlobLiteral("x'1A2B3'", 8),
        ),
        // Unterminated blob literal
        ("x'1A2B3C", TokenizerError::UnterminatedLiteral("x'1A2B3C")),
        // Wrong quote terminator
        (
            "x'1A2B3C\"",
            TokenizerError::MalformedBlobLiteral("x'1A2B3C\"", 8),
        ),
        // Non-hex characters
        ("x'ZZ'", TokenizerError::MalformedBlobLiteral("x'ZZ'", 2)),
        // Extra characters after blob
        // ("x'1234'5", ParsingError::MalformedBlobLiteral("x'1234'", 3)),

        // // Unexpected characters after blob
        // ("x'1A2B3C'abc", ParsingError::MalformedBlobLiteral("x'1A2B3C'", 3)),
    ];

    for (sql, expected) in invalid_test_cases {
        run_rainy_day_test(sql, vec![], expected);
    }
}
