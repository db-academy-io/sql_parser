// THIS IS AN AUTOGENERATED TESTS, DO NOT MODIFY!
//
// The cargo dbcheck will generate the test files for each stage of the course.
// Be careful; these files are not intended to be edited by students. You're
// free to add more tests in separate files, but don't delete or edit tests
// generated by the testing tool

/* --------------- TESTS DERIVED FROM TOKENIZER SPECIFICATION ---------------
 *             (see https://www.sqlite.org/draft/tokenreq.html)
 */
#![allow(non_snake_case)]

mod common;
use common::{run_rainy_day_test, run_sunny_day_test};
use sql_parser::{ParsingError, TokenType};

/// H41200: SQLite shall recognize as a STRING token a sequence of characters
/// that begins with a single-quote (u0027), is followed by zero or more
/// non-zero characters and/or pairs of single-quotes (u0027) and terminates
/// with a single-quote (u0027) that is not part of a pair.
#[test]
fn test_H41200() {
    let valid_test_cases = vec![
        ("''", vec![TokenType::String("''")]),
        (
            "'Hello, world!'",
            vec![TokenType::String("'Hello, world!'")],
        ),
        (
            "'It''s a nice day'",
            vec![TokenType::String("'It''s a nice day'")],
        ),
        (
            "'He said, ''Hello!'' and left.'",
            vec![TokenType::String("'He said, ''Hello!'' and left.'")],
        ),
        (
            "'''starting with quote'",
            vec![TokenType::String("'''starting with quote'")],
        ),
        (
            "'ending with quote'''",
            vec![TokenType::String("'ending with quote'''")],
        ),
        (
            "'multiple ''''quotes'",
            vec![TokenType::String("'multiple ''''quotes'")],
        ),
        (
            "'123''456''789'",
            vec![TokenType::String("'123''456''789'")],
        ),
    ];

    for (sql, expected_tokens) in valid_test_cases {
        run_sunny_day_test(sql, expected_tokens);
    }
}

#[test]
fn test_H41200_rainy_day_cases() {
    let invalid_test_cases = vec![
        // Missing closing quote
        (
            "'Missing closing quote",
            ParsingError::UnterminatedLiteral("'Missing closing quote"),
        ),
        // Last quote is part of a pair, missing final quote
        (
            "'Ends with pair''",
            ParsingError::UnterminatedLiteral("'Ends with pair''"),
        ),
    ];

    for (sql, expected) in invalid_test_cases {
        run_rainy_day_test(sql, vec![], expected);
    }
}
