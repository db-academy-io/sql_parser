// THIS IS AN AUTOGENERATED TESTS, DO NOT MODIFY!
//
// The cargo dbcheck will generate the test files for each stage of the course.
// Be careful; these files are not intended to be edited by students. You're
// free to add more tests in separate files, but don't delete or edit tests
// generated by the testing tool

/* --------------- TESTS DERIVED FROM TOKENIZER SPECIFICATION ---------------
 *             (see https://www.sqlite.org/draft/tokenreq.html)
 */
#![allow(non_snake_case)]

mod common;
use common::{run_rainy_day_test, run_sunny_day_test};
use sql_parser::{Keyword, TokenType, TokenizerError};

/// H41100: SQLite shall recognize a sequence of one or more MultiLineComment
/// characters as a MultiLineComment token.
#[test]
fn test_H41100() {
    use Keyword::*;

    let test_cases = vec![
        (
            "SELECT\t*\tFROM\tusers;",
            vec![
                TokenType::Keyword(Select),
                TokenType::Star,
                TokenType::Keyword(From),
                TokenType::Id("users"),
                TokenType::Semi,
            ],
        ),
        (
            "INSERT  INTO  users  (id,  name)  VALUES  (1,  'Alice');",
            vec![
                TokenType::Keyword(Insert),
                TokenType::Keyword(Into),
                TokenType::Id("users"),
                TokenType::LeftParen,
                TokenType::Id("id"),
                TokenType::Comma,
                TokenType::Id("name"),
                TokenType::RightParen,
                TokenType::Keyword(Values),
                TokenType::LeftParen,
                TokenType::Integer("1"),
                TokenType::Comma,
                TokenType::String("'Alice'"),
                TokenType::RightParen,
                TokenType::Semi,
            ],
        ),
        (
            "UPDATE\tusers\tSET\tname\t=\t'Bob'\tWHERE\tid\t=\t2;",
            vec![
                TokenType::Keyword(Update),
                TokenType::Id("users"),
                TokenType::Keyword(Set),
                TokenType::Id("name"),
                TokenType::Equals,
                TokenType::String("'Bob'"),
                TokenType::Keyword(Where),
                TokenType::Id("id"),
                TokenType::Equals,
                TokenType::Integer("2"),
                TokenType::Semi,
            ],
        ),
        (
            "DELETE  FROM  users  WHERE  id  = 3;",
            vec![
                TokenType::Keyword(Delete),
                TokenType::Keyword(From),
                TokenType::Id("users"),
                TokenType::Keyword(Where),
                TokenType::Id("id"),
                TokenType::Equals,
                TokenType::Integer("3"),
                TokenType::Semi,
            ],
        ),
        (
            "CREATE TABLE test (\n    id INTEGER,\n    name TEXT\n);",
            vec![
                TokenType::Keyword(Create),
                TokenType::Keyword(Table),
                TokenType::Id("test"),
                TokenType::LeftParen,
                TokenType::Id("id"),
                TokenType::Id("INTEGER"),
                TokenType::Comma,
                TokenType::Id("name"),
                TokenType::Id("TEXT"),
                TokenType::RightParen,
                TokenType::Semi,
            ],
        ),
        (
            "SELECT * FROM users WHERE name = 'Charlie';",
            vec![
                TokenType::Keyword(Select),
                TokenType::Star,
                TokenType::Keyword(From),
                TokenType::Id("users"),
                TokenType::Keyword(Where),
                TokenType::Id("name"),
                TokenType::Equals,
                TokenType::String("'Charlie'"),
                TokenType::Semi,
            ],
        ),
        (
            "   SELECT   *   FROM   users   ;",
            vec![
                TokenType::Keyword(Select),
                TokenType::Star,
                TokenType::Keyword(From),
                TokenType::Id("users"),
                TokenType::Semi,
            ],
        ),
        (
            "SELECT\t*\tFROM\tusers\tWHERE\tage\t>\t25;",
            vec![
                TokenType::Keyword(Select),
                TokenType::Star,
                TokenType::Keyword(From),
                TokenType::Id("users"),
                TokenType::Keyword(Where),
                TokenType::Id("age"),
                TokenType::GreaterThan,
                TokenType::Integer("25"),
                TokenType::Semi,
            ],
        ),
        (
            "SELECT *\nFROM users\nWHERE id = 4;",
            vec![
                TokenType::Keyword(Select),
                TokenType::Star,
                TokenType::Keyword(From),
                TokenType::Id("users"),
                TokenType::Keyword(Where),
                TokenType::Id("id"),
                TokenType::Equals,
                TokenType::Integer("4"),
                TokenType::Semi,
            ],
        ),
    ];

    for (sql, expected_tokens) in test_cases {
        run_sunny_day_test(sql, expected_tokens);
    }
}

/// H41110: SQLite shall recognize as a MultiLineComment token the two-character
/// sequence "--" (u002d, u002d) followed by any sequence of non-zero
/// characters up through and including the first u000a character or until
/// end of input.
#[test]
fn test_H41110() {
    use Keyword::*;
    let test_cases = vec![
        (
            "SELECT * FROM users; -- This is a comment\nSELECT * FROM orders;",
            vec![
                TokenType::Keyword(Select),
                TokenType::Star,
                TokenType::Keyword(From),
                TokenType::Id("users"),
                TokenType::Semi,
                TokenType::SingleLineComment(" This is a comment\n"),
                TokenType::Keyword(Select),
                TokenType::Star,
                TokenType::Keyword(From),
                TokenType::Id("orders"),
                TokenType::Semi,
            ],
        ),
        // (
        //     "-- Full line comment\nSELECT id FROM users;",
        //     vec![
        //         TokenType::SingleLineComment(" Full line comment\n"),
        //         TokenType::Keyword(Select),
        //         TokenType::Id("id"),
        //         TokenType::Keyword(From),
        //         TokenType::Id("users"),
        //         TokenType::Semi,
        //     ],
        // ),
        // (
        //     "SELECT * FROM users; -- Comment without newline",
        //     vec![
        //         TokenType::Keyword(Select),
        //         TokenType::Star,
        //         TokenType::Keyword(From),
        //         TokenType::Id("users"),
        //         TokenType::Semi,
        //         TokenType::SingleLineComment(" Comment without newline"),
        //         TokenType::Semi,
        //     ],
        // ),
        // (
        //     "SELECT * FROM users; --\n",
        //     vec![
        //         TokenType::Keyword(Select),
        //         TokenType::Star,
        //         TokenType::Keyword(From),
        //         TokenType::Id("users"),
        //         TokenType::Semi,
        //         TokenType::SingleLineComment("\n"),
        //     ],
        // ),
        // (
        //     "SELECT * FROM users; --",
        //     vec![
        //         TokenType::Keyword(Select),
        //         TokenType::Star,
        //         TokenType::Keyword(From),
        //         TokenType::Id("users"),
        //         TokenType::Semi,
        //         TokenType::SingleLineComment(""),
        //     ],
        // ),
        // (
        //     "SELECT * FROM users; -- Comment with -- inside\n",
        //     vec![
        //         TokenType::Keyword(Select),
        //         TokenType::Star,
        //         TokenType::Keyword(From),
        //         TokenType::Id("users"),
        //         TokenType::Semi,
        //         TokenType::SingleLineComment(" Comment with -- inside\n"),
        //     ],
        // ),
        // (
        //     "SELECT * FROM users; --Comment without space\n",
        //     vec![
        //         TokenType::Keyword(Select),
        //         TokenType::Star,
        //         TokenType::Keyword(From),
        //         TokenType::Id("users"),
        //         TokenType::Semi,
        //         TokenType::SingleLineComment("Comment without space\n"),
        //     ],
        // ),
        // (
        //     "SELECT * FROM users; --\n-- Another comment\nSELECT * FROM products;",
        //     vec![
        //         TokenType::Keyword(Select),
        //         TokenType::Star,
        //         TokenType::Keyword(From),
        //         TokenType::Id("users"),
        //         TokenType::Semi,
        //         TokenType::SingleLineComment("\n"),
        //         TokenType::SingleLineComment(" Another comment\n"),
        //         TokenType::Keyword(Select),
        //         TokenType::Star,
        //         TokenType::Keyword(From),
        //         TokenType::Id("products"),
        //         TokenType::Semi,
        //     ],
        // ),
        // (
        //     "-- Comment at end of input",
        //     vec![TokenType::SingleLineComment(" Comment at end of input")],
        // ),
    ];

    for (sql, expected_tokens) in test_cases {
        run_sunny_day_test(sql, expected_tokens);
    }
}

/// H41120: SQLite shall recognize as a MultiLineComment token the
/// two-character sequence "/*" (u002f, u002a) followed by any sequence of zero
/// or more non-zero characters through with the first "*/" (u002a, u002f)
/// sequence or until end of input.
#[test]
fn test_H41120() {
    use Keyword::*;
    let test_cases = vec![
        (
            "SELECT * FROM users; /* This is a comment */ SELECT * FROM orders;",
            vec![
                TokenType::Keyword(Select),
                TokenType::Star,
                TokenType::Keyword(From),
                TokenType::Id("users"),
                TokenType::Semi,
                TokenType::MultiLineComment(" This is a comment "),
                TokenType::Keyword(Select),
                TokenType::Star,
                TokenType::Keyword(From),
                TokenType::Id("orders"),
                TokenType::Semi,
            ],
        ),
        (
            "/* Full line comment */\nSELECT id FROM users;",
            vec![
                TokenType::MultiLineComment(" Full line comment "),
                TokenType::Keyword(Select),
                TokenType::Id("id"),
                TokenType::Keyword(From),
                TokenType::Id("users"),
                TokenType::Semi,
            ],
        ),
        (
            "SELECT * FROM users; /*\nMulti-line\nComment\n*/",
            vec![
                TokenType::Keyword(Select),
                TokenType::Star,
                TokenType::Keyword(From),
                TokenType::Id("users"),
                TokenType::Semi,
                TokenType::MultiLineComment("\nMulti-line\nComment\n"),
                TokenType::Semi,
            ],
        ),
        (
            "SELECT * FROM users; /* Empty comment */",
            vec![
                TokenType::Keyword(Select),
                TokenType::Star,
                TokenType::Keyword(From),
                TokenType::Id("users"),
                TokenType::Semi,
                TokenType::MultiLineComment(" Empty comment "),
                TokenType::Semi,
            ],
        ),
        (
            "/* Nested /* comments */ not supported */",
            vec![
                TokenType::MultiLineComment(" Nested /* comments "),
                TokenType::Keyword(Not),
                TokenType::Id("supported"),
                TokenType::Star,
                TokenType::Slash,
                TokenType::Semi,
            ],
        ),
    ];

    for (sql, expected_tokens) in test_cases {
        run_sunny_day_test(sql, expected_tokens);
    }
}

#[test]
fn test_H41120_rainy_day_case() {
    let invalid_test_cases = vec![
        // Comment without terminator
        (
            "/* Comment without terminator'",
            vec![],
            TokenizerError::UnterminatedCommentBlock,
        ),
    ];

    for (sql, tokens, expected_error) in invalid_test_cases {
        run_rainy_day_test(sql, tokens, expected_error);
    }
}
